\section{CrashSimulator Approach Details}

    % TODO: Verify information on supported trace formats %%%
    % TODO: Assume all program are deterministic and will end. Unit test individual functions by putting in script
    \subsection{Architecture}

        At a high level CrashSimulator is organized into three primary modules. First, there is the system call trace
        parser. This module is responsible for interpreting the input system call traces and identifying opportunities
        to inject faults into the application under test. Second, there is the test control module. This module is
        responsible for iterating through the list of potential anomalies generated by the system call trace parser and
        in order to test each one of them. Finally, there is the test launcher. This module is responsible for launching
        the application under test and performing the interactions necessary to inject the test fault and monitor the
        application's response.

        CrashSimulator was architected this was in order to maximize code reuse and portability. A great deal of work
        has already been accomplished by NetCheck and CheckAPI in the domain of system call trace parsing. \emph{Strace}
        and \emph{dtrace} both produce output that was primarily intended for human rather than programmatic
        consumption. As such, reuse of their parsing code resulted in a large time savings and increased confidence in
        parsing accuracy.

        The test launcher was separated from the test controller for the sake of portability. A great deal of the test
        launcher's code deals with the low level details of process manipulation and monitoring and, as such, will
        likely require modification in order to operate on different platforms than the authors' original development
        environments. For example, in order to modify the return value of particular system calls on x86 systems, the
        test launcher must hook the application under test using \emph{ptrace} and modify the values of the EAX register
        upon completion of the system call. This modification is tightly coupled to x86 calling conventions. Even the
        relatively similar x86--64 differs in that the test launcher must use \emph{ptrace} to modify the RAX register
        rather than the EAX register. Other architectures, such as ARM, will likely require more extensive
        modifications.

        All three primary CrashSimulator modules are packaged together and interact with each other at the appropriate
        times without user intervention. At this point, CrashSimulator itself is available as a virtual machine
        appliance compatible with the \emph{Virtual Box} virtual machine hosting software. The reasons for distributing
        CrashSimulator in this manner are threefold. First, this distribution method ensures that all of
        CrashSimulator's dependences are installed and configured appropriately. Second, this method provides an
        environment for taking system call traces that is known to be complete tool-wise and compatible with
        CrashSimulator. Finally, and most importantly, this method provides an environment that is known to be
        compatible with the low level details of CrashSimulator's fault injection techniques.

        CrashSimulator's source code is available and, while other environments may be untested, it should function
        correctly on any platforms that meet the criteria described above.

    \subsection{System Call Traces}

        % TODO: What denotes an interesting system call??

        The first step in CrashSimulator's operation is to gather a trace of the system calls made by the application
        during a normal run. Where other tools base their operation of direct analysis of the application under test
        CrashSimulator operates based on information gleaned from system call traces. This gives CrashSimulator several
        advantages over similar tools. First, CrashSimulator operates in a language independent manner. It can test any
        program given two conditions hold true:

        \begin{enumerate}
            \item{The application can run in the testing environment}
            \item{The testing environment has the tooling required to take a system call trace of the application during
            a normal run}
        \end{enumerate}

        This removes the need for the complex language parsing that other similar tools rely on. Second, the faults
        injected by CrashSimulator test the interface between the application under test and its environment. Other
        similar testing tools focus on testing the logic within the application under test which missing faults that
        only appear when the application is run in an imperfect, real world environment.

        Because CrashSimulator's trace analysis engine is based on prior work from the NetCheck supported trace
        gathering tools include \emph{strace} on Linux and \emph{dtrace} on OS X.


    \subsection{Supported Anomaly Types}

        \textbf{I would really like to find another term besides anomaly}

        CrashSimulator's goal when analyzing a normal run system call trace is to identify individual system calls or
        patterns of system calls that it recognizes as an opportunity to inject a fault during subsequent runs. These
        signatures are referred to as ``potential anomalies.'' CrashSimulator has the ability to identify and make use
        of several classifications of potential anomalies.

        \subsubsection{Return Value Modification}

            One way CrashSimulator can inject faults into the running application is to modify the return values of
            interesting system calls identified in the previous trace analysis step. The primary driver behind injecting
            this type of fault is the tendency of developers to misuse common API functions or misunderstand their
            failure modes. For example, a developer that is unfamiliar with the operation of a \emph{recv} system call
            may fail to account for cases where it return all of the data expected. A well written application might
            make repeated calls to recv until it has gathered all the data it needs while an incorrectly written
            application may only call it once resulting in a fault when it tries to process incomplete data in the
            future.

            % TODO: Make sure terminology is correct in this paragraph
            % TODO: Is this methodology reasonable?
            The authors' implementation of CrashSimulator injects this fault using ptrace. The application under test is
            executed in a process that is hooked by ptrace and each system call made by the application is examined.
            When a system call that was previously identified as a target is encountered execution interrupted
            immediately upon its completion. At this point the return value of the system call is modified using rules
            defined on a per system call basis. These rules are based on the system calls normal operation and return
            values. For example, if a recv call is identified as interesting and returns a positive value (i.e.\ success)
            in the normal system call trace, this same call would be modified to return -1 (i.e.\ error) during a test
            run. Other modifications would include changing the positive return value to 0 and to some other positive
            number that is less than the original return value.

        \subsubsection{Data Reordering}

        \subsubsection{Data Truncation}

    \subsection{Trace Analysis}



    \subsection{Fault Injection}

        Once a set of potential fault injection points has been identified CrashSimulator uses \emph{ptrace} inject
        faults on a live execution of the program. At this point, two faults types identifiable by NetCheck are
        supported: modification of return values from network system calls and reordering of UDP packets.  These faults
        were chosen because of high impact they can have on applications that don't handle them properly and the
        frequency with which developers have an incorrect understanding of how these system calls can behave in an
        imperfect environment.

        % What is the process for culling our set of unit tests for instances where there are a huge number of
        % permutations of packet orderings
        \subsection{Catalog-Based Anomalies}

        A second category of faults CrashSimulator can produce are known as catalog-based faults. These faults are
        injected in two steps. First, the normal run trace is parsed in its entirety for system calls in a specific set
        associated with the fault being injected and the data items passed into these system calls are recorded in a
        data item catalog. Next, the application under test is run repeatedly with each run receiving a different
        ordering of data items from the catalog for the corresponding system calls. One example of a fault
        CrashSimulator can inject in such situations is unhandled out of order UDP datagrams. Consider the following
        pseudo-code listing:

        % TODO: Use the real C Code here
        \begin{verbatim}
int main() {
    socket = setupUdpSocket()
    data1 = recvfrom(socket)
    processData1(data1)
    data2 = recvfrom(socket)
    processData2(data2)
}
        \end{verbatim}

        This listing sets up a UDP socket and receives two datagrams from the socket processing each with the
        appropriate function. A C program that implements this pseudo-code will produce a normal flow system call trace
        as follows:

        \begin{verbatim}
...
socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP) = 3
bind(3, {sa_family=AF_INET, sin_port=htons(6666), sin_addr=inet_addr("0.0.0.0")}, 16) = 0
recvfrom(3, "test\n", 256, 0, {sa_family=AF_INET, sin_port=htons(51490), sin_addr=inet_addr("127.0.0.1")}, [16]) = 5
...
write(1, "Process 1: test\n", 16)       = 16
recvfrom(3, "testagain\n", 256, 0, {sa_family=AF_INET, sin_port=htons(51490), sin_addr=inet_addr("127.0.0.1")}, [16]) = 10
write(1, "Process 2: testagain\n", 21)  = 21
...
        \end{verbatim}

        The above program assumes that datagram 1 will always arrive first and datagram 2 will always arrive second. UDP
        makes no ordering guarantees so the reverse is possible. This would result in datagram 2 being processed as
        datagram 1 and vice versa. Crash simulator would inject this fault as follows. First, it would parse the system
        call trace and identify all calls to recvfrom, storing the data that was received in a data catalog and the
        identifying information pertaining to the socket it was received from. Second, it would re-run the application
        under test and send a different ordering of data from the data catalog to the socket in question. From the above
        example, ``testagain'' would be sent to the first receive from and ``test'' would be sent to the second recvfrom
        resulting in each data item being parsed by the incorrect function. CrashSimulator would then report
        abnormalities in the application's behavior. \textbf{How are we going to handle situations where this is a
        silent failure}

