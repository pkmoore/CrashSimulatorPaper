\section{Evaluation}

    This work hopes to answer the following questions about CrashSimulator's operation:

        \begin{enumerate}
            \item{Is CrashSimulator successful in identifying flaws in new and existing applications?}
            \item{Is CrashSimulator able to execute tests in a performant manner?}
        \end{enumerate}

    % TODO: Talk about the test platform, OS, Hardware, etc.
    \subsection{Execution Performance}

        One key attribute of successful testing tools is that they be able to complete their tests in a timely manner.
        If a tool takes too long to complete its tests users will be less likely to run it frequently, or at all,
        reducing the tools overall usefulness dramatically. To this end, the performance of CrashSimulator was evaluated
        in order to determine whether or not it was able to complete its test executions in an acceptable time frame.
        \textbf{There probably needs to be a citation here related to how long a developer is typically willing to wait
        for a test execution to complete}

        \subsubsection{Evaluation Against Sample Programs}

        Each of the following evaluations eamines the completion times for 20 consecurive executions of the specified
        application in both native and replay execution modes.  Multiple conseuritve executions were used for two
        reasons.  First, a single execution in either mode completes so quickly for the applications in question as to
        be nearly indistinguishable from the other mode.  Second, multiple executions somewhat contros for varying
        conditions like filesystem activity or network latency that can vary between individual executions.

            \begin{table}[H]
                \scriptsize{}
                \begin{tabular}{l  l  l  l}
                    \toprule{}
                        Execution Description & Native Eecution & Replay Execution\\
                        network\_speedtest & 0.024 & 2.407 \\
                        filesystem\_speedtest & 0.038 & 2.604 \\
                    \bottomrule{}
                \end{tabular}
            \end{table}

        \paragraph{Discussion on network\_speedtest}

        Sample application opens a TCP connection toan already running listener (netcat), sends a message, and
        exits. For simple applications like this, native execution is significantly faster than replay execution...

        \paragraph{Discussion on filesystem\_speedtest}

        This ample application create a new file with open(), writes a message to it, closes the file descriptor, and
        exit()'s. This test is particularly meaningful as it replicates a pattern of system calls that is used for in
        all sorts of applications in Linux...
            
    \subsection{Bugs Identified in Major Applications}

        \subsubsection{Identification of Known Bugs}

        Another way we evaluated the efficacy of CrashSimulator was on its ability to detect known bugs as recorded in
        the bug trackers of major open source software projects.

            \paragraph{Race Condition in shutil.copy, shutil.copy2, shutil.copyfile - Bug ID\# 15100}
              
            This bug describes a situation where the described functions in the shutil package do not perform the checks
            necessary to prevent a race condition around the process of copying a file from one filesystem to another --
            a situation that prevents the use of the safer rename() system call.  CrashSimulator is able to detect this
            issue in replayed executions of python applications that make use of these functions by identifying the
            applications failure to use fstat() to verify that a file has not changed between the time the file was
            first checked with stat() and when it was open()'d at the start of the copy process.

        \subsubsection{Identification of Unknown Bugs}

        \subsubsection{Cross-Device Move Bugs}

        In Linux, the rename() system call will only move a file if the source and destination are on the same device.
        This means that moving a file from a directory structure location on one storage device to a directory structure location on
        another device must be handled on a case-by-case basis by any application that relies on this operation.  With
        this in mined, we examined the process by which the coreutils ``mv'' command handles this task and constructed
        computational models that can determine whether or not a replayed execution of an application has performed all
        the necessary steps to successfully carry out a cross device move.  Next, these models were employed during
        replayed executions of the listed applications in order to determine whether or not their copy operation is correct.

        \paragraph{Verify Destination is not Target of Source}

        In this condition, CrashSimulator confirms whether or not the application under test performs a check to ensure
        that the source file name is not a symlink pointing to the destination file name.  If this check is not
        performed, loss of data is possible due to removal or overwriting of the destination during the copy process
        resulting in the source symlink pointing to nothing.

        \paragraph{Preserve Extended File Attributes}

        In this condition, CrashSimulator determines whether or not the application under test correctly preserves
        extended file attributes by reading them from the source file and applying them to the destination file prior to
        removing the source file.  Extended file attributes are often used to store information such as the original
        providance of the file (i.e. downloaded from the internet, received from an trusted vendor, etc.).  Loss of
        these attributes can result in security issues. For example, Apple's Gatekeeper relies on extended file
        attributes to prevent applications downloaded untrusted developers from being executed without user
        confirmation.

        \paragraph{Ensure Source is not Replaced Between Check and Copy}

        This is an example of a classic race condition.  In this case, CrashSimulator examines whether or not the
        appication under test makes uses of fstat() to ensure that the inode number of the file being copied has not
        changed between initial examination with a stat()-like call and the eventual copy.  

        \paragraph{Preserve Timestamp and Mode}

        Truely copying a file means preserving the metadata of the file as well as its contents.  In this condition,
        CrashSimulator ascertains whether or not the application under test restores the appropriate timestamps and
        modeline to the destination file after (or before) its contents have been copied. 

        \paragraph{Move Block Device Across Disks}

        Many applications fail to examine the nature of a file before engaging in a manual, cross-disk copy process.  In
        situations where the source is a special file such as /dev/urandom.  If an application fails to detect this
        situation, the typical steps in a manual copy process could result in the application filling the destination
        destination device, consuming available memory, or simply hanging indefinitely as it attempts to read in the
        full contents of an effectively infinite-sized file.

        
            \begin{table}[H]
                \scriptsize{}
                \begin{tabular}{l  l  l  l}
                \toprule{}
                  Application & Condition Tested & Correct Response\\
                  mv & Verify Destination is not Target of Source & Yes\\
                  mv & Preserve Extended File Attributes & Yes\\
                  mv & File Replaced Between Check And Copy & Yes\\
                  mv & Preserve Timestamp and Mode & Yes\\
                  mv & Move Directory Into Itself & Yes\\
                  mv & Move Block Device Across Disks & Yes\\
                  Python shutils & Verify Destination is not Target of Source & Yes\\
                  Python shutils & Preserve Extended File Attributes & \textbf{No}\\
                  Python shutils  & File Replaced Between Check And Copy & \textbf{no}\\
                  Python shutils  & Preserve Timestamp and Mode & \textbf{No}\\
                  Python shutils  & Move Directory Into Itself & Yes\\
                  Python shutils  & Move Block Device Across Disks & Yes\\
                  mmv & Verify Destination is not Target of Source& \textbf{No}\\
                  mmv & Preserve Extended File Attributes & \textbf{No}\\
                  mmv & File Replaced Between Check And Copy & \textbf{No}\\
                  mmv & Preserve Timestamp and Mode & Yes\\
                  mmv & Move Directory Into Itself & Yes\\
                  mmv & Move Block Device Across Disks & \textbf{No}\\
                  rust & Verify Destination is not Target of Source& \textbf{???}\\
                  rust & Preserve Extended File Attributes & \textbf{???}\\
                  rust & File Replaced Between Check And Copy & \textbf{???}\\
                  rust & Preserve Timestamp and Mode & \textbf{???}\\
                  rust & Move Directory Into Itself & \textbf{???}\\
                  rust & Move Block Device Across Disks & \textbf{???}\\
                \bottomrule{}
                \end{tabular}
            \end{table}

        \subsubsection{Non-Regular File Bugs}

        These bugs involve modifying the executions of applications that work with regular files such that a call to
        stat() or lstat() indicates that the file in question is instead some sort of special file.  Well behaved
        applications should verify that the files they are accessing are regular files before processing them.  Many
        applications make the assumption that they will only be used to process regular files.  Encountering special
        files tends to induce a denial of service condition that in certain circumstances, such as an automated
        environment, can halt a scripted process or workflow.

            \begin{table}[H]
                \scriptsize{}
                \begin{tabular}{l  l  l  l}
                \toprule{}
                  Application & Condition Tested & Correct Response\\
                  gnu-gpg & Replace gpg.conf with FIFO & \textbf{no}, application hangs\\
                  vim & Replace file being opened with FIFO & \textbf{no}, application hangs\\
                  nano & Replace file being opened with FIFO & \textbf{no}, application hangs\\
                  sed & Replace file being edited with FIFO & \textbf{no}, appliation hangs\\
                \bottomrule{}
                \end{tabular}
            \end{table}
        
        
        

    \subsection{Limitations}

        Evaluation of CrashSimulator has yielded the following limitations to be addressed by future work.

        \paragraph{Coupling to Architecture}

            As some faults injected by CrashSimulator require low level access to the test system's hardware or
            operating system data structures there exists some degree of coupling between CrashSimulator and these
            components. One area of expansion for CrashSimulator is support for more processor architectures and more
            operating systems.  CrashSimulator's test launcher as been designed in such a way that these improvements
            should be trivial to plug in once they have been implemented.
