\section{Introduction}

    One major hurdle in developing robust applications is anticipating and dealing with edge conditions and faults that
    compromise and applications ability to run as intended. A common source of faults is the environment in which an
    application runs. In an increasingly diverse software ecosystem it is not uncommon for problematic differences to
    appear between two different platforms. Whether it happens because of a lack of adherence to standards, intentional
    divergence, or developer error the result is the same: software written to run on multiple platforms falls victim to
    the differences between those platforms. These can easily go unnoticed due to the infeasibility of testing software
    across every combination of hardware and software on which it is expected to run. The typical approach to
    eliminating faults of any kind in an application is the creation of a suite of tests that exercise the applications
    functionality and ensure that it always acts appropriately. In the case of issues that arise from an application's
    environment it is not possible to enumerate and test for an acceptable amount of faults due to the variety of
    hardware and software systems that can make up the environment.

    This problem is of particular concern in the context of today's highly network dependent applications. With the
    explosion of mobile computing and ``software as a service'' products applications that are completely reliant on
    well-behaved network communication are increasingly common. As a result a great deal of emphasis must be placed on
    properly dealing with faults in these network communications. Unfortunately, identifying these faults is difficult
    due to the inability of the developer to replicate all possible application environments and exhaust all possible
    code paths.

    In an attempt to remedy this situation, a wide variety of automated testing tools have been developed. These tools
    typically follow either a black-box or white-box approach. In the case of white-box testing, the tools attempt to
    gain an understanding of the application by analyzing its code with the goal of generating inputs that most
    efficiently exercise the application's code paths. In the case of black-box testing, the tools simply mutate inputs
    in order to achieve a similar goal. Both of these techniques have their advantages and disadvantages. CrashSimulator
    attempts to collect the good parts from each of these techniques into a single utility.

    In light of these shortcomings, an alternative approach is needed to provide developers with confidence that their
    applications are sufficiently free of environment induced faults.  CrashSimulator is a tool designed to meet this
    need by providing automated identification of environment-induced faults through simulated deviations from the
    normal flow of system calls an application makes when interacting with its environment. Like other white-box tools,
    CrashSimulator attempts to analyze an application in order to understand where it can inject faults.  However,
    unlike other tools it bypasses the application's source code entirely --- instead relying on system call traces.
    This reduces CrashSimulator's footprint by eliminating complex language analysis code while still allowing insight
    into the application's operation. At the same time, CrashSimulator, like other black-box tools, is able to test
    applications in the absence of source code. Furthermore, because it bases its analysis on a successful run of the
    application in a real environment this analysis takes into account the application's interactions with its
    environment. During its analysis, CrashSimulator identifies sets of system calls that represent areas likely to
    contain faults. Once analysis is complete, CrashSimulator runs the application under test and injects the faults it
    identified previously and reports to the developer whether or not the application successfully handled them or not.
    For example, CrashSimulator might identify a system call that rarely fails and, as a result, this failure is rarely
    handled in practice. It can then inject this failure and observe the results.

    CrashSimulator makes the following contributions:

    \begin{enumerate}
        \item{CrashSimulator is the first tool to use system call traces recorded in one environment as a basis for
            injecting faults into an application running in another environment}
        \item{CrashSimulator is able to produce thousands of mutated system call traces per minute even when operating
            on large system call traces from complex applications}
        \item{CrashSimulator's pluggable anomaly generation utilities allow new anomalies to be identified with minimal
            new code}
        \item{CrashSimulator is able to identify errors listed in the bug trackers of major projects and predicted by
            other testing tools}
    \end{enumerate}
