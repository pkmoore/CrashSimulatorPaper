\section{Background and Motivation}

CrashSimulator operates in a unique niche in relation to other testing tools and techniques. As a result, it is better
suited to identify and report on certain types of errors that relate to the environment in which an application is
running.

    \subsection{What is an ``Environment''}

    An application's environment is the collection of all resources external to the application with which the
    application communicates.  These external resources can be thought of as an implicit input to the program as their
    presence and contents alter the flow of any application executed in their presence. CrashSimulator is concerned with
    bugs that arise from subtle differences in behavior between executions in one environment versus another
    specifically, the files and network communications visible through the monitoring the system calls the application
    makes during the course of its execution.

    As an example of how the implementations of different environments can impact the execution of an application
    consider the following bug identified by NetCheck.  In BSD and OS X sockets returned by the {\tt
      accept()} system call inherit the values of the {\tt O\_NONBLOCK} and {\tt O\_ASYNC} flags from their parent
    socket.  In Linux, these values are not inherited.  As a result, the correct behavior is to always explicitly
    set these flags to the appropriate values on child sockets.  This difference environmental difference presented
    itself as a bug in the socket implementation of Python 3.2.  Python took advantage of non-blocking sockets in
    order to implement timeout capabilities for sockets.  Because Python did not specifically set the {\tt O\_NONBLOCK}
    flag on the child sockets underlying its socket object abstraction it was possible that, depending on the
    environment, the Python socket object would report the socket as either blocking or non-blocking while the actual
    underlying socket was configured for the opposite behavior.  This is the sort of bug that CrashSimulator focuses on
    identifying and is the sort of bug that application-focused testing techniques are typically not capable of finding.

    \subsection{An Example from CrashSimulator}

    Moving files around in a filesystem is an extremely common operation that, on face value, seems to fairly simplistic
    to carry out.  In reality, things become complex quickly once a few implementation details are taken into account:
    namely limitations in Linux's {\tt rename()} system call and the way Linux's directory heirarchy can abstract away
    complicated device configurations -- a feature is usually a boon for developers.

    In this example, consider a Linux directory structure with two folders, {\tt /mnt/a/} and {\tt /mnt/b/}, with each
    being a mount point for a different storage device.  Moving a file around anywhere inside either of these
    directories can be trivially accomplished by an application using the {\tt rename()} system call.  Because it is
    common for systems to have the majority of their directory structures residing on the same device this approach
    appropriate.  Another case would be moving a file from {\tt /mnt/a/} to {\tt /mnt/b/} when the source and destination are on
    different storage devices.  In this case, {\tt rename()} is incapable of performing the operation.  When situation
    presents itself, an application must both detect the error returned by {\tt rename()} and manually copy the file from one
    device to the other -- a complex process that is easy to carry out incorrectly.  \emph{Any} application that moves
    files around on a Linux system must be able to deal with this situation any part of the drirectory structure may
    physically reside on a different device.  For example, the standard log storage location, {\tt /var/log/}, may be stored
    on a separate, higher speed, device in order to accomodate a high volume of reads and writes.

    During the course of its evaluation, we provided CrashSimulator with the computational models necessary to detect
    whether or not the applications being tested successfully performed all of the steps necessary to manually copy a
    file from one device to another.  We used the coreutils {\tt mv}command source code as a guide for what constituted
    correct behavior as this utility is a key component of Linux systems and must be robust enough to correctly deal
    with any edge cases or unusual situations that arise.

    A variety of applications that move files around in a filesystem were tested using CrashSimulator with these
    capabilities enabled.  A particularly illustrative example is the {\tt shutils} module that ships with Python 2.7.9.
    CrashSimulator was able to diagnose the module as failing on several points: it did not correctly preserve
    timestamps across the move, it did not correctly apply extended file attributes to the destination file after the
    move, and it did not verify the file's inode number between initially examining the source file and when the copy
    was initiated (a common cause of race conditions.)  After these tests were performed, we found an unresolved bug
    report from several years ago discussing this issue on Python's bug tracker -- a nice bit of confirmation of
    CrashSimulator's efficacy.

    These deficiencies are not just inconveniences.  They can have a real world impact on a system's operation and
    security.  Consider the case of not correctly copying timestamps when when moving a file.  If other code depends on
    timestamps for ordering its processing then moving the file via {\tt shutils} can result in a silent mis-ordering of
    its processing.  This could be disaster in order-dependent situations like batching updates to a database.

    In the case of failing to confirm a file's inode before moving it a possible outcome is a completely different file
    ending up in the destination than was at the source.  Consider the situation where a service using Python's {\tt
      shutils} is responsible for copying files to a privileged location from a public area.  Because {\tt shutils} does
    not open and confirm the inode number of the file prior to copying it, there is a window where some outside actor
    could replace the file being copied silently between the first time {\tt stat()} is used to check it and when the
    copy actually takes place.  From the service's perspective, there is no indication that anything other than the
    correct file was copied to the privileged area while, in reality, a completely different file was copied.

    There are security concerns in not correctly copying extended file attributes to the destination file as well.  Some
    operationg systems rely on these extended file attribute attach information where a file came from to the file
    itself.  This information is later used by these operating systems to make decision about whether the file should be
    executed or not and by whom it may be executed.  In this case, moving the file from one device to another using
    Python's {\tt shutils} will result in this information being stripped meaning that the operating system cannot make
    correct decisions about how to handle the file in the future.

    This is just one example.  Given the variety of device types, file systems, and configurations possible it is not
    hard to imagine a wide extent of problematic combinations that could arise.  This is the sort of situation in which
    CrashSimulator excels.  CrashSimulator can induce error conditions or passively monitor an execution.  It can
    either look for the presence of good behavior (e.g. ``Did this application correctly copy extended file attributes
    when moving a file across disks?'') or it can identify the presence of bad behavior (e.g. ``Did this application try to
    interact with a block device as if it were a regular file?'').  
