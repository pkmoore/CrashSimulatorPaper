\section{Background and Motivation}

    CrashSimulator operates in a unique niche in relation to other testing tools and techniques. As a result, it is
    better suited to identify and report on certain types of error that relate to the environment in which an
    application is running.

    \subsection{Existing Techniques}

        Existing tools can be roughly divided into two categories, black-box and white-box, based on the techniques they
        use to perform their testing. Black-box tools simply manipulate the inputs of the application under test and
        observe the resultant outputs. White-box tools, on the other hand, perform complex analysis of the application
        under test's source code in order to reason about what inputs are likely to produce interesting outputs. Each of
        these methodologies have their own advantages and disadvantages.

        White-box testing tools typically rely on a similar set of techniques including constraint solving of branch
        statements in an application's code and symbolic execution of an application's code in order to generate inputs
        that optimally exercise the application's code paths. These techniques, while powerful, are not without their
        downsides.  First, symbolic execution is computationally expensive and can result in deviations where the
        symbolic execution of code doesn't accurately represent the actual execution of code.  Similarly, efficiently
        solving a series of constraints in order to exercise a particular code path can be computationally expensive and
        it can be difficult to guarantee that a particular set of generated inputs will exercise the intended code path
        in many circumstances due to external dependencies that the tool cannot analyze. For example, a white-box
        testing tool cannot generate inputs that are guaranteed to exercise a code path that relies on an operating
        system resource being available. Finally, white-box tools typically require than an application's source code be
        available which is not always the case. Even advanced white-box tools that analyze an application's machine code
        can be stymied in situations where an application's executable has been packed or encrypted.

        The alternative, black-box tools, have their own set of issues. They do not have an understanding of what an
        application is actually doing during execution which means they are only able to submit inputs and observe
        outputs.  The upside of this technique is simplicity. Black-box tools do not need the capability to understand
        and analyze an application's code which reduces their complexity immensely. Also, their testing process,
        mutating inputs and observing outputs, is computationally inexpensive. The downside of simplicity is that they
        cannot craft inputs with any sort of intelligence. This means that a great deal of time can be spent mutating
        inputs without much success in terms of bug identification. Also, they cannot identify specifically the source
        of faults in an application. They can only signal that a fault has occurred at some point during a test run.
        Furthermore, like white-box tools, these tools fail to take into account the environment in which the
        application is running.

    \subsection{System Call Trace Analysis}

        CrashSimulator is based on prior work from two projects: NetCheck and CheckAPI. It makes use of these tools to
        analyze system call traces captured from an execution of the application under test in order to determine
        locations that are likely to to be sources of faults. At this time, traces captured using strace and dtrace are
        supported as they are the standard tools made available for this purpose in Linux and OS X respectively. Each
        system call is evaluated within the context of prior system calls. NetCheck and CheckAPI take system call
        ordering, parameters and return values into account as it looks for opportunities to inject anomalies.

    \subsection{Crash Simulation}

        Once CrashSimulator has generated a series of potential faults from its analysis of an application's system call
        trace the process of verifying the presence of faults can begin. This is accomplished by producing a new copy of
        the ideal system call trace that has been mutated to include an anomaly that was identified during analysis.
        Next, this system call trace is replayed. The results of this faulty execution are monitored and any deviations
        in output from the ``correct'' output are recorded.  Faults that result in an application crashing are also
        recorded.

    \subsection{A Real World Example}

        \textbf{\emph{This is an example based on a fake tool. It is rough but I can polish it more if this example is
        on the right track.}}

        TimeSync hosts hardware atomic clocks and leases access to them for clock synchronization purposes to
        organizations with highly sensitive timing needs. As part of this service they distribute TDaemon, a Linux
        daemon that make use of a proprietary protocol to synchronize the clock of the machine it is running on with the
        TimeSync's atomic clocks. TimeSync's expertise was in the setup and maintenance of atomic clocks, not in the
        construction and maintenance of a highly distributed system. A few years after opening for business, TimeSync's
        developers decided that the low level communication code for TDaemon needed to be re-written in a newer
        programming language. Unfortunately, during this rewrite a junior developer failed to handle situations where a
        \emph{connect} attempt failed. These failed connects caused TDaemon to silently retry its connection without
        success. All testing of TDaemon utility was performed on TimeSync's local network which had firewall rules in
        place that allowed development environments to freely access the atomic clocks. When the new version of TDaemon
        was rolled out, it began silently failing on networks with more restrictive firewall rules. Because TDaemon was
        written to silently retry the connection until successful, these failures went unnoticed. As a result, at many
        of TimeSync's locations, system clocks slowly became out of sync resulting in significant damage to experiments
        and experimental data.

        The above events are a prime situation in which automated testing and CrashSimulator in particular would have
        saved a great deal of trouble. CrashSimulator is capable of injecting failed \emph{connect} calls into
        applications during its test runs. As a result, CrashSimulator would produced and reported TDaemon's abnormal
        behavior in spite of the ideal network conditions present in TDaemon's development environment.
